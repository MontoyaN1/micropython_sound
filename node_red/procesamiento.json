{
  "id": "a05f17d0d8f5931e",
  "type": "function",
  "z": "f6f2187d.f17ca8",
  "name": "Procesar datos",
  "func": "if (!msg?.payload) {\n  node.error(\"Mensaje o payload no definido\");\n  return null;\n}\n\nconst data = msg.payload;\n\nif (!Array.isArray(data?.sensors) || data.sensors.length === 0) {\n  node.error(\"No hay datos de sensores en el payload\");\n  return null;\n}\n\nconst lines = [];\n\nfor (let sensor of data.sensors) {\n  // Validar campos requeridos\n  if (sensor.micro_id === undefined || sensor.value === undefined) {\n    node.warn(`Sensor incompleto: ${JSON.stringify(sensor)}`);\n    continue;\n  }\n\n  // Escapar caracteres especiales en el tag (micro_id)\n  const escapeTag = (v) =>\n    String(v).replace(/ /g, \"\\\\ \").replace(/,/g, \"\\\\,\").replace(/=/g, \"\\\\=\");\n\n  const microId = escapeTag(sensor.micro_id);\n\n  // Construir línea SOLO con measurement, tag y field\n  // SIN timestamp para que InfluxDB use la hora del servidor\n  // SIN sample\n  let line = `sonido,micro_id=${microId} valor=${sensor.value}`;\n\n  lines.push(line);\n}\n\n// Unir con salto de línea\nmsg.payload = lines.join(\"\\n\");\n\n// Metadata opcional (sin timestampNs)\nmsg.metadata = {\n  originalMessageId: data.message_id,\n  sensorCount: data.sensors.length,\n  processedAt: new Date().toISOString(),\n};\n\nreturn msg;",
  "outputs": 1,
  "timeout": 0,
  "noerr": 0,
  "initialize": "",
  "finalize": "",
  "libs": [],
  "x": 580,
  "y": 340,
  "wires": [["a8a462b7369f84e1"]]
}
